<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Orlando Chen"><meta name="copyright" content="Orlando Chen"><meta name="generator" content="Hexo 6.1.0"><meta name="theme" content="hexo-theme-yun"><title>算法学习---贪心算法 | Orlando的窝</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"orlando-chen.github.io","root":"/","title":"CYFの小破站","version":"1.9.0","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":null},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="简述定义：在求解最优解问题的过程中，依据某种贪心标准，从问题的初始状态出发，直接去求每一步的最优解，通过若干次的贪心选择，最终得出整个问题的最终解，这种求解方法就是贪心算法。  贪心算法所做的选择可以依赖于以往所做过的选择，但绝不依赖于将来的选择，也不依赖于子问题的解。  原理： 局部最优解来达到全局最优解。 但是遗憾的是这种算法并不是总能得到最优解，并且是否能得到最优解还取决于对于贪心策略的选择">
<meta property="og:type" content="article">
<meta property="og:title" content="算法学习---贪心算法">
<meta property="og:url" content="https://orlando-chen.github.io/2022/05/21/GA/index.html">
<meta property="og:site_name" content="Orlando的窝">
<meta property="og:description" content="简述定义：在求解最优解问题的过程中，依据某种贪心标准，从问题的初始状态出发，直接去求每一步的最优解，通过若干次的贪心选择，最终得出整个问题的最终解，这种求解方法就是贪心算法。  贪心算法所做的选择可以依赖于以往所做过的选择，但绝不依赖于将来的选择，也不依赖于子问题的解。  原理： 局部最优解来达到全局最优解。 但是遗憾的是这种算法并不是总能得到最优解，并且是否能得到最优解还取决于对于贪心策略的选择">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190930093345993.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190930093406115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poaV9uZW5nX3poaV9mdQ==,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2022-05-21T08:11:00.349Z">
<meta property="article:modified_time" content="2022-05-23T15:18:57.827Z">
<meta property="article:author" content="Orlando Chen">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190930093345993.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Orlando Chen"><img width="96" loading="lazy" src="/images/avatar.png" alt="Orlando Chen"><span class="site-author-status" title="Wish you a good day!">🦄</span></a><div class="site-author-name"><a href="/about/">Orlando Chen</a></div><span class="site-name">Orlando的窝</span><sub class="site-subtitle">修狗SayHi!</sub><div class="site-description">落俗不可避免</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">16</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Orlando-Chen" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=252444264" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">简述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">原理：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">设计贪心算法步骤：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">基本要素：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">基本思想：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">特点：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E6%A1%88%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">典型案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">找零问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">2.1.2.</span> <span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.3.</span> <span class="toc-text">算法实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">活动选择问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.2.4.</span> <span class="toc-text">时间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.</span> <span class="toc-text">集合覆盖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">2.3.3.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">2.3.4.</span> <span class="toc-text">时间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.</span> <span class="toc-text">删数问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">2.4.3.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">2.4.4.</span> <span class="toc-text">时间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.</span> <span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-4"><span class="toc-number">2.5.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-4"><span class="toc-number">2.5.2.</span> <span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">2.5.3.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="toc-number">2.5.4.</span> <span class="toc-text">时间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">2.6.</span> <span class="toc-text">单源最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-5"><span class="toc-number">2.6.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-5"><span class="toc-number">2.6.2.</span> <span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-number">2.6.3.</span> <span class="toc-text">典型算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">2.6.4.</span> <span class="toc-text">算法实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">贪心算法练习题</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://orlando-chen.github.io/2022/05/21/GA/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Orlando Chen"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Orlando的窝"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">算法学习---贪心算法</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2022-05-21 16:11:00" itemprop="dateCreated datePublished" datetime="2022-05-21T16:11:00+08:00">2022-05-21</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2022-05-23 23:18:57" itemprop="dateModified" datetime="2022-05-23T23:18:57+08:00">2022-05-23</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>在求解最优解问题的过程中，依据某种贪心标准，从问题的初始状态出发，直接去求每一步的最优解，通过若干次的贪心选择，最终得出整个问题的最终解，这种求解方法就是贪心算法。</p>
<blockquote>
<p>贪心算法所做的选择可以依赖于以往所做过的选择，但绝不依赖于将来的选择，也不依赖于子问题的解。</p>
</blockquote>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><ul>
<li>局部最优解来达到全局最优解。</li>
<li>但是遗憾的是这种算法并不是总能得到最优解，并且是否能得到最优解还取决于对于贪心策略的选择。</li>
</ul>
<h2 id="设计贪心算法步骤："><a href="#设计贪心算法步骤：" class="headerlink" title="设计贪心算法步骤："></a>设计贪心算法步骤：</h2><ol>
<li>确定问题的最优子结构</li>
<li>基于问题的最优子结构设计一个递归算法</li>
<li>证明我们做出的贪心选择，只剩下一个子问题</li>
<li>证明贪心选择总是安全的</li>
<li>设计一个递归算法实现贪心策略</li>
<li>将贪心算法转化为迭代算法</li>
</ol>
<h2 id="基本要素："><a href="#基本要素：" class="headerlink" title="基本要素："></a>基本要素：</h2><p>贪心算法常用于解决最大值或最小值的优化问题。</p>
<ul>
<li>贪心选择性质：所求问题的整体最优解可以通过一系列局部最优的选择（即贪心选择）来达到。贪心算法通常自顶向下，以迭代的方式做出相继的贪心选择。</li>
<li>最优子结构性质：一个问题的最优解包含其子问题的最优解。</li>
</ul>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>在对问题求解时，总是做出在当前看来是最好的选择。</p>
<h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul>
<li>不是从整体考虑——得到的解可能不是全局最优。</li>
<li>简单，直接，易理解，效率高。</li>
<li>贪心算法虽然不能对所有的问题都求得整体最优解，但是对大部分的问题都能求得最优近似解，对部分问题也能得到最优解，例如单源最短路径、最小生成树等。</li>
</ul>
<h1 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a><strong>典型案例</strong></h1><h2 id="找零问题"><a href="#找零问题" class="headerlink" title="找零问题"></a>找零问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>假设有面值为50元、20元、10元、5元、1元的货币，现需要找给顾客x元现金，求最少给出的货币总数。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>在现实的合理货币标准下，找零问题是最简单的贪心算法例题之一。若货币标准由题目给定，可能需要动态规划求解。</li>
<li>设y∈{50,20,10,5,1}使得找x-y元现金成为原问题的一个子问题，当Wx为原问题的最优解时，W(x-y)&#x3D;Wx-1必然是原问题的最优解；否则原问题将有Wx’&#x3D;W(x-y)+1 &lt; Wx的更优解。由上反证法可证明找零问题具有最优子结构性质。</li>
<li>在题目所给条件下，该问题也具有贪心选择性质。<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心算法求最小货币数,cash为货币数组,x为找零总数,res为各货币使用总数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMinCash</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> *cash,<span class="type">int</span> *res)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(cash);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= cash[i])&#123;</span><br><span class="line">            x -= cash[i];</span><br><span class="line">            ++res[i];</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="活动选择问题"><a href="#活动选择问题" class="headerlink" title="活动选择问题"></a>活动选择问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>设n个活动的集合E&#x3D;{1,2,…,n}，每个活动需要使用统一资源，而同一时间只能有一个活动使用这一资源。每个活动i都有一个开始时间si和一个结束时间fi，且必有si &lt; fi。任意一个活动将在半开区间[si,fi)内占用资源。对于两个活动i和j，若区间[si,fi)和[sj,fj)不相交，称i和j是<strong>相容</strong>的；否则称i和j是<strong>不相容</strong>的或<strong>冲突</strong>的。求在一定时间内所能安排活动的最大数，也即求集合E的最大相容子集。</p>
<h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>该问题等效于线段覆盖问题中的<strong>最多不相交线段覆盖</strong>。</li>
<li>活动安排问题是贪心算法有效求解的例题之一。我们选择结束时间作为贪心选择的标准，每次都选择当前可容的结束时间最早的活动。这样做的目的是为剩余的未安排活动留下尽可能多的时间。该问题的最优子结构性质可由数学归纳法证明；贪心选择性质可由反证法证明。</li>
<li>正确性证明思路：<ul>
<li>对算法执行步数进行归纳。</li>
<li>归纳基础：先证明存在一个最优解包含右端点最小的区间（否则可以进行替换）。</li>
<li>归纳步骤：对选出的活动个数k进行归纳，证明最优解去掉前k个的活动，是剩下集合的最优解，否则矛盾，必然存在对剩下的集合的最优解包含第一个活动，归纳结论成立。<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3>按照右端点（活动结束时间）升序排序，依次添加线段。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取最大相容活动个数和子集,s为开始时间集合,f为结束时间集合,n为活动总数,res为选择的活动</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMaxActivity</span><span class="params">(<span class="type">int</span> *s,<span class="type">int</span> *f,<span class="type">bool</span>* res,<span class="type">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> lastF = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= lastF)&#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            res[i] = <span class="literal">true</span>;</span><br><span class="line">            lastF = f[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3>对于已经给定非降序序列，主要时间消耗在遍历序列上，故时间复杂度为O(n)；若给定序列无序，还需要进行排序，则时间复杂度由排序的时间复杂度决定，通常为O(nlog n)。</li>
</ul>
</li>
</ul>
<h2 id="集合覆盖问题"><a href="#集合覆盖问题" class="headerlink" title="集合覆盖问题"></a>集合覆盖问题</h2><p>选择最少的集合，覆盖全部的元素。</p>
<h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>设n个活动的集合E&#x3D;{1,2,…,n}，每个活动需要使用统一资源，而同一时间只能有一个活动使用这一资源。每个活动i都有一个开始时间si和一个结束时间fi，且必有si &lt; fi。任意一个活动将在半开区间[si,fi)内占用资源。对于两个活动i和j，若区间[si,fi)和[sj,fj)不相交，称i和j是<strong>相容</strong>的；否则称i和j是<strong>不相容</strong>的或<strong>冲突</strong>的。求在一定时间内所能安排活动的最大数，也即求集合E的最大相容子集。</p>
<table>
<thead>
<tr>
<th align="center">广播台</th>
<th align="center">覆盖的州</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(1) KONE</td>
<td align="center">ID，NV，UT</td>
</tr>
<tr>
<td align="center">(3) KTHREE</td>
<td align="center">OR，NV，CA</td>
</tr>
<tr>
<td align="center">(4) KFOUR</td>
<td align="center">NV，UT</td>
</tr>
<tr>
<td align="center">(5) KFIVE</td>
<td align="center">CA，ZA</td>
</tr>
</tbody></table>
<h3 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h3><p>如何找出覆盖全美 50 5050 个州的最小广播台集合呢？<br>最容易考虑到的可能是暴力求解法：列出每一种可能的广播集合（可能的子集有2^n个）；在这些集合中选出能覆盖全美50个州的最小集合数。假设每秒可筛选出10个子集，其花费的时间如下：<br><img src="https://img-blog.csdnimg.cn/20190930093345993.png" alt="花费时间" loading="lazy"><br>使用贪婪算法可以得到非常接近的解：</p>
<ol>
<li>选出这样一个广播台，即它覆盖了最多的未被选择的州。即便这个广播台覆盖了一些已经选择的州，也没有关系；</li>
<li>重复第一步，直到覆盖了所有的州。<br>贪婪算法是不错的选择，它们不仅简单，而且通常运行速度很快。在这个例子中，贪婪算法的运行时间为O(n^2)，其中n为广播台数量。<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3>第一步：准备工作：构建数据结构；</li>
</ol>
<ul>
<li>用集合 states_needed 存储所有的州；</li>
<li>用字典表示电视台 stations 的覆盖面；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">states_needed = <span class="built_in">set</span>([<span class="string">&#x27;mt&#x27;</span>, <span class="string">&#x27;wa&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;nv&#x27;</span>, <span class="string">&#x27;ut&#x27;</span>, <span class="string">&#x27;ca&#x27;</span>, <span class="string">&#x27;az&#x27;</span>]) # 包含要覆盖的州</span><br><span class="line"></span><br><span class="line">stations = &#123;&#125; # 存储电视台集合</span><br><span class="line">stations[<span class="string">&quot;kone&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;id&quot;</span>, <span class="string">&quot;nv&quot;</span>, <span class="string">&quot;ut&quot;</span>])</span><br><span class="line">stations[<span class="string">&quot;ktwo&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;wa&quot;</span>, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;mt&quot;</span>])</span><br><span class="line">stations[<span class="string">&quot;kthree&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;or&quot;</span>, <span class="string">&quot;nv&quot;</span>, <span class="string">&quot;ca&quot;</span>])</span><br><span class="line">stations[<span class="string">&quot;kfour&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;nv&quot;</span>, <span class="string">&quot;ut&quot;</span>])</span><br><span class="line">stations[<span class="string">&quot;kfive&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;ca&quot;</span>, <span class="string">&quot;az&quot;</span>])</span><br><span class="line"></span><br><span class="line">final_stations = <span class="built_in">set</span>() # 存储最终电视台的集合</span><br></pre></td></tr></table></figure>
第二步：利用贪心算法求解最少的电视台</li>
<li>选出这样一个广播台，即它覆盖了最多的未被选择的州。我们将这个广播台存储在 best_station 中；</li>
<li>重复第一步，直到覆盖了所有的州。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> states_needed:</span><br><span class="line">    best_station = None # 最佳电视台:覆盖了最多未覆盖的州</span><br><span class="line">    states_covered = <span class="built_in">set</span>() # 最佳电视台与未覆盖州集合的交集</span><br><span class="line">    <span class="keyword">for</span> station, states in stations.<span class="built_in">items</span>():</span><br><span class="line">        covered = states_needed &amp; states # 当前广播台与未覆盖州集合的交集</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(covered) &gt; <span class="built_in">len</span>(states_covered):</span><br><span class="line">            states_covered = covered</span><br><span class="line">            best_station = station</span><br><span class="line">    </span><br><span class="line">    states_needed -= states_covered # 更新未覆盖州的集合</span><br><span class="line">    final_stations.<span class="built_in">add</span>(best_station) # 添加贪心算法选择的电台</span><br></pre></td></tr></table></figure>
最终打印结果可能是：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(final_stations)</span><br><span class="line"><span class="meta"># set([<span class="string">&#x27;ktwo&#x27;</span>, <span class="string">&#x27;kthree&#x27;</span>, <span class="string">&#x27;kone&#x27;</span>, <span class="string">&#x27;kfive&#x27;</span>])</span></span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3>求解实践对比：<br><img src="https://img-blog.csdnimg.cn/20190930093406115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poaV9uZW5nX3poaV9mdQ==,size_16,color_FFFFFF,t_70" alt="对比" loading="lazy"></li>
</ul>
<h2 id="删数问题"><a href="#删数问题" class="headerlink" title="删数问题"></a>删数问题</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>对给定的数字串x1x2…xn，删除其中的k个数字，使得剩余数字按原次序组成的新数字最大。</p>
<h3 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>对于一个长整数，其高位数字越大，数字也就越大。若存在xi与xi+1满足xi &lt; xi+1，则删除xi必然能使数字变大；当序列已经呈非增序时，删除末尾的元素。由于越高位的数字对数字的大小影响也越大，由此可以从左端开始遍历，每次遇到第一个删除的数字就是当前的局部最优解。而每次贪心选择后，问题都化为n-1的子问题，因此该问题具有贪心选择性质。</li>
<li>设An为n问题的最优解，而An-1是n-1问题的最优解。若An-1不是n-1问题的最优解，设该最优解为Bn-1，满足Bn-1&gt;An-1，那么补上删除的xi后，必有An &#x3D; An-1 + xi · 10n-i &lt; Bn-1 + xi · 10n-i &#x3D; Bn，即存在Bn&gt;An满足Bn为更优解。由上反证法可得，该问题具有最优子结构性质。<h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x为数字序列,k为需要删除的数字个数,n为序列长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMaxAfterDelK</span><span class="params">(<span class="type">int</span>* x,<span class="type">int</span> k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t &lt; k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x[i] &lt; x[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> tmp = x[i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i;j &lt;= n - t - <span class="number">1</span>;j++)	<span class="comment">//被删元素后的元素前移</span></span><br><span class="line">                    x[j] = x[j+<span class="number">1</span>];</span><br><span class="line">                x[n-t] = tmp;</span><br><span class="line">                ++t;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == n)  <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度分析-2"><a href="#时间复杂度分析-2" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3>删数问题的贪心算法主要时间消耗在遍历数组和移动数组上，共循环k次，所以时间复杂度为O(kn)。</li>
</ul>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定n种物品和一个容量为C的背包，物品i的重量为wi，价值为vi，如何选择装入背包的物品，使得背包中物品总价值最大？</p>
<h3 id="问题分析-4"><a href="#问题分析-4" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>在前面学习动态规划时提到过，<strong>背包问题</strong>分为两种：<strong>0-1背包问题</strong>和<strong>可拆分背包问题</strong>(简称<strong>背包问题</strong>)。对于0-1背包问题，由于背包剩余空间可能降低物品的单位重量价值，因此不适用贪心算法，而适用动态规划。而这里将讨论物品<strong>物品可拆分的背包问题。</strong></li>
<li>由于背包的容量是有限的，因此物品的重量和价值都会对结果产生影响。因此我们首先得到每一个物品单位重量的价值<strong>vi&#x2F;wi</strong>，以物品的<strong>单位重量价值</strong>作为贪心选择的标准。每次选择<strong>单位重量价值</strong>最高的物品加入背包。</li>
<li>每次贪心选择放入R%的物品i后，我们的问题就变成C - R% · wi的背包容量与剩余物品集合的背包问题了。设原问题的最优解为A，子问题的最优解为A’。设子问题有更优解满足B’ &gt; A’，那么加上背包内的价值R% · vi后，可以得到A &#x3D; A’ + R% · vi &lt; B’ + R% · vi &#x3D; B，即B为原问题的更优解。如上反证法可得该问题具有<strong>最优子结构性质</strong>。</li>
<li>设k为原问题或原问题的一个子问题。对于k的第一个选择，若该选择为贪心选择，则满足贪心选择性质；若该选择不为贪心选择，可以将其替换为贪心选择，而不影响之后的选择，使得得到的新解优于原解。因此，该问题具有<strong>贪心选择性质</strong>。<h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//物品结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    <span class="type">double</span> w;</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">    <span class="type">double</span> v_w;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//objects为物品集合,c为背包容量,n为集合长度,res储存物品的选取重量</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getMaxBagValue</span><span class="params">(Object* objects,<span class="type">double</span> c,<span class="type">int</span> n,<span class="type">double</span>* res)</span>    <span class="comment">//贪心算法求背包能放的最高价值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(objects+<span class="number">1</span>,objects+n+<span class="number">1</span>,[](Object a,Object b)-&gt;<span class="type">bool</span>&#123;<span class="keyword">return</span> a.v_w &gt; b.v_w;&#125;);	<span class="comment">//对物品按单位重量排序</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= objects[i].w)&#123;		<span class="comment">//能完全装入的完全装入</span></span><br><span class="line">        c -= objects[i].w;</span><br><span class="line">        value += objects[i].v;</span><br><span class="line">        res[objects[i].i] += objects[i].w;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c &gt; <span class="number">0</span>)&#123;						<span class="comment">//不能完全装入的，将剩余空间填满</span></span><br><span class="line">        <span class="type">double</span> r = c / objects[i].w;</span><br><span class="line">        value += r * objects[i].v;</span><br><span class="line">        res[objects[i].i] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度分析-3"><a href="#时间复杂度分析-3" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3>背包问题的贪心算法时间主要消耗在对物品序列排序，其时间复杂度通常为O(nlog n)；若给出的序列以满足按单位重量价值非增序，则时间消耗主要在遍历物品序列上，其时间复杂度为O(n)。</li>
</ul>
<h2 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个<strong>带权有向图G&#x3D;{V,E}<strong>，每条边的权值为非负实数。从图上的一点v0(<strong>源</strong>)出发，求到达任意另一点vi的</strong>最短路径</strong>。</p>
<h3 id="问题分析-5"><a href="#问题分析-5" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>最短路径问题显然具有<strong>最优子结构性质</strong>：最短路径必然能分成多个子问题的最短路径，否则该路径可以以最短路径替代，以得到更优的路径。</li>
<li>最短路径问题的<strong>贪心选择性质</strong>证明如下：<br>  我们取当前的最短路径为<strong>贪心选择标准</strong>，若最短路径不具有贪心选择性质，则必然存在点vx位于贪心路径之外。那么v0到vi的最短路径d(0,i)可以表示为：<strong>d(0,i) &#x3D; d(0,x) + d(x,i)<strong>。<br>  设v0到vi的贪心选择路径为dist(0,i)，则一定有：</strong>d(0,i) &lt; dist(0,i)<strong>。由于各边的权值均为非负，那么应有：</strong>d(0,x) ≤ d(0,i)<strong>。再由上面的第二个式子可以得到：</strong>d(0,x) &lt; dist(0,i)<strong>。这个式子表示</strong>顶点v0到vx的距离小于v0到vi的贪心选择距离</strong>。根据贪心选择的定义，vx应当在贪心选择路径中。<br>  由上反证法可证明最短路径问题的贪心选择性质。<h3 id="典型算法"><a href="#典型算法" class="headerlink" title="典型算法"></a>典型算法</h3></li>
<li><strong>Dijkstra算法</strong>是典型的最短路径算法。它将顶点分为两个集合：<strong>已得到最短路径的顶点集合S</strong>和<strong>未确定最短路径的顶点集合V-S</strong>，并设一个数组<strong>D</strong>保存v0到V-S内顶点的<strong>当前最短路径</strong>。</li>
<li>算法步骤如下：<ul>
<li>初始状态下，S中只有v0，D中记录v0到其它各顶点<strong>出弧的权值</strong>；若不邻接，则记为无穷大。</li>
<li>从D中选择一条<strong>最短</strong>、且<strong>邻接点不在S中</strong>的路径，并将邻接点<strong>加入S中</strong>，该最短路径就是v0到该点的<strong>最短路径</strong>。</li>
<li>遍历该邻接点的所有出弧，计算<strong>出弧的权值</strong>与<strong>源到邻接点最短路径</strong>的和，并与D中记录的<strong>源到弧头的最短路径</strong>比较。如果和小于原记录，则更新数组D。</li>
<li>重复步骤2和3，直到<strong>所有的顶点</strong>都加入S，或<strong>目标顶点vi</strong> 加入S。<h3 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">	<span class="type">int</span> **martix;	<span class="comment">//邻接矩阵</span></span><br><span class="line">	<span class="type">int</span> v;			<span class="comment">//顶点个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//G为图,dist为最短路径数组,prev为前置顶点集合,v0为出发点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(Graph G,<span class="type">int</span>* dist,<span class="type">int</span> *prev,<span class="type">int</span> v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> visited[G.v] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    visited[v0] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.v;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G.martix[v0][i] &gt; <span class="number">0</span> &amp;&amp; i != v0)&#123;</span><br><span class="line">            dist[i] = G.martix[v0][i];</span><br><span class="line">            prev[i] = v0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dist[i] = <span class="number">0x7fffffff</span>;</span><br><span class="line">            prev[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[v0] = <span class="number">0</span>;</span><br><span class="line">    prev[v0] = v0;</span><br><span class="line">    <span class="comment">//循环n-1次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.v;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == v0)     <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> min_num = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="type">int</span> v;                  <span class="comment">//下一个加入的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; G.v;j++)&#123;     <span class="comment">//遍历查询最短的路径</span></span><br><span class="line">            <span class="keyword">if</span>(visited[j] == <span class="literal">false</span> &amp;&amp; dist[j] &lt; min_num)&#123;</span><br><span class="line">                min_num = dist[j];</span><br><span class="line">                v = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; G.v;j++)&#123;     <span class="comment">//更新dist</span></span><br><span class="line">            <span class="keyword">if</span>(visited[j] == <span class="literal">false</span> &amp;&amp; G.martix[v][j] &gt; <span class="number">0</span> &amp;&amp; min_num + G.martix[v][j] &lt; dist[j])&#123;</span><br><span class="line">                dist[j] = min_num + G.martix[v][j];</span><br><span class="line">                prev[j] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造最优路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPath</span><span class="params">(<span class="type">int</span>* prev,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v == prev[v])</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;v&#x27;</span> &lt;&lt; v;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;v&#x27;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;&lt;-&quot;</span>;</span><br><span class="line">        <span class="built_in">showPath</span>(prev,prev[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="贪心算法练习题"><a href="#贪心算法练习题" class="headerlink" title="贪心算法练习题"></a><strong>贪心算法练习题</strong></h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ziyanblog/p/15685273.html">见此博客</a></p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Orlando Chen</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://orlando-chen.github.io/2022/05/21/GA/" title="算法学习---贪心算法">https://orlando-chen.github.io/2022/05/21/GA/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/05/21/GAvsDP/" rel="prev" title="算法学习---贪心算法VS动态规划"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">算法学习---贪心算法VS动态规划</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/05/18/NP/" rel="next" title="算法学习---NP问题"><span class="post-nav-text">算法学习---NP问题</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Orlando Chen</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v6.1.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.9.0</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>