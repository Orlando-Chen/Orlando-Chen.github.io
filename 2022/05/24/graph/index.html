<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Orlando Chen"><meta name="copyright" content="Orlando Chen"><meta name="generator" content="Hexo 6.1.0"><meta name="theme" content="hexo-theme-yun"><title>算法学习---图的基本算法 | Orlando的窝</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"orlando-chen.github.io","root":"/","title":"CYFの小破站","version":"1.9.0","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":null},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="简述图的定义： 图G由两个集合V和E组成，记为G&#x3D;(V,E)，其中V是顶点的有穷集合，E是顶点偶对（边）的有穷集合。 V(G),E(G)通常代表图G的顶点集合和边集合。若E(G)为有向边的集合，则该图为有向图；若E(G)为无向边的集合，则该图为无向图。  图的基本术语：子图、无向完全图和有向完全图、稠密图与稀疏图、邻接点、度和入度和出度、路径和路径长度、回路或环、连通和连通图和联通分量、">
<meta property="og:type" content="article">
<meta property="og:title" content="算法学习---图的基本算法">
<meta property="og:url" content="https://orlando-chen.github.io/2022/05/24/graph/index.html">
<meta property="og:site_name" content="Orlando的窝">
<meta property="og:description" content="简述图的定义： 图G由两个集合V和E组成，记为G&#x3D;(V,E)，其中V是顶点的有穷集合，E是顶点偶对（边）的有穷集合。 V(G),E(G)通常代表图G的顶点集合和边集合。若E(G)为有向边的集合，则该图为有向图；若E(G)为无向边的集合，则该图为无向图。  图的基本术语：子图、无向完全图和有向完全图、稠密图与稀疏图、邻接点、度和入度和出度、路径和路径长度、回路或环、连通和连通图和联通分量、">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200829051207372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5MDcwNDk=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190614102539684.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODcxNjU2Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190614123537568.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODcxNjU2Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181122094334465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbnk4MjA0MTg=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181122094526106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbnk4MjA0MTg=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190614110614659.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODcxNjU2Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181122094654893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbnk4MjA0MTg=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181122100134811.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181122100041483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbnk4MjA0MTg=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181122103041714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbnk4MjA0MTg=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181128111557505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbnk4MjA0MTg=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181122103948656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbnk4MjA0MTg=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/6cdb8fcefeca4c2aaf507254c6d4f250.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rWq6YeM5bCP55m96b6ZbmJ3,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019061417370630.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODcxNjU2Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019061417370630.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODcxNjU2Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190802211019465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NfWmhhbmdTaXI=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ff7553b5fd9341bd81e3a25af07790ab.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/21e7cae3528540809d314009d87a7af2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rWq6YeM5bCP55m96b6ZbmJ3,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://orlando-chen.github.io/images/BFS.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1485495/201907/1485495-20190707192821931-136919482.png">
<meta property="og:image" content="https://orlando-chen.github.io/images/BFST1.png">
<meta property="og:image" content="https://orlando-chen.github.io/images/BFST2.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1749451/201909/1749451-20190921121215388-749051872.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1749451/201909/1749451-20190921121447386-1658019050.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1749451/201909/1749451-20190921121522859-1841133664.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1749451/201909/1749451-20190921122333141-1771436400.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1749451/201909/1749451-20190921121537724-31133813.png">
<meta property="og:image" content="https://orlando-chen.github.io/images/Topo1.png">
<meta property="og:image" content="https://orlando-chen.github.io/images/Topo2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210421164716512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoeVRhbg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://orlando-chen.github.io/images/TopoEg1.png">
<meta property="og:image" content="https://orlando-chen.github.io/images/TopoEg2.png">
<meta property="article:published_time" content="2022-05-24T05:54:58.595Z">
<meta property="article:modified_time" content="2022-05-31T00:09:03.921Z">
<meta property="article:author" content="Orlando Chen">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200829051207372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5MDcwNDk=,size_16,color_FFFFFF,t_70#pic_center"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Orlando Chen"><img width="96" loading="lazy" src="/images/avatar.png" alt="Orlando Chen"><span class="site-author-status" title="Wish you a good day!">🦄</span></a><div class="site-author-name"><a href="/about/">Orlando Chen</a></div><span class="site-name">Orlando的窝</span><sub class="site-subtitle">修狗SayHi!</sub><div class="site-description">落俗不可避免</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">8</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Orlando-Chen" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=252444264" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">简述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">图的定义：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">图的基本术语：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">图的实例：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%EF%BC%88%E5%9B%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">图的表示（图的数据结构）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">邻接表与邻接矩阵：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">邻接表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83%E5%9B%BE%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">加权图表示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">2.1.2.</span> <span class="toc-text">邻接矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83%E5%9B%BE%E8%A1%A8%E7%A4%BA-1"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">加权图表示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">十字链表法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">邻接多重表：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84%E6%B3%95%EF%BC%9A"><span class="toc-number">2.4.</span> <span class="toc-text">边集数组法：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E6%90%9C%E7%B4%A2%EF%BC%88DFS-amp-BFS%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">图的搜索（DFS &amp; BFS）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">深度优先搜索（DFS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">3.1.1.</span> <span class="toc-text">思想：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">3.1.2.</span> <span class="toc-text">模拟搜索过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">3.1.3.</span> <span class="toc-text">表示方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DFS%E4%B8%AD%E8%BE%B9%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">3.1.4.</span> <span class="toc-text">DFS中边的相关问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">3.1.5.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%93%E7%8E%B0%E5%9B%9E%E6%BA%AF"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">体现回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E2%80%94n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">剪枝优化———n-皇后问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">广度优先搜索（BFS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%A1%86%E6%9E%B6%EF%BC%9A"><span class="toc-number">3.2.2.</span> <span class="toc-text">搜索框架：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A"><span class="toc-number">3.2.3.</span> <span class="toc-text">应用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%9A"><span class="toc-number">3.2.4.</span> <span class="toc-text">流程图：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">3.2.5.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E8%89%B2%E6%96%B9%E5%9D%97"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">黑色方块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Word-Ladder"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">Word Ladder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Word-Break-II"><span class="toc-number">3.2.5.3.</span> <span class="toc-text">Word Break II</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90"><span class="toc-number">3.2.6.</span> <span class="toc-text">总结分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%B8%8E%E5%B9%BF%E5%BA%A6%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.3.</span> <span class="toc-text">深度与广度的比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E6%94%AF"><span class="toc-number">4.</span> <span class="toc-text">强连通分支</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-1"><span class="toc-number">4.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tarjan%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">Tarjan算法：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">4.2.1.</span> <span class="toc-text">算法过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tarjan%E7%AE%97%E6%B3%95%E7%94%A8%E9%80%94%EF%BC%9A"><span class="toc-number">4.2.2.</span> <span class="toc-text">Tarjan算法用途：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E7%BC%A9%E7%82%B9"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">有向图的缩点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">求割点和桥</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B"><span class="toc-number">4.2.3.</span> <span class="toc-text">例题————受欢迎的牛</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3"><span class="toc-number">5.2.</span> <span class="toc-text">理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">5.3.</span> <span class="toc-text">基本实现思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-number">5.4.</span> <span class="toc-text">算法思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E6%80%9D%E8%B7%AF"><span class="toc-number">5.4.1.</span> <span class="toc-text">初步思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-number">5.4.2.</span> <span class="toc-text">优化算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.5.</span> <span class="toc-text">拓扑排序方法实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">5.6.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B1"><span class="toc-number">5.6.1.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B2"><span class="toc-number">5.6.2.</span> <span class="toc-text">例2</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://orlando-chen.github.io/2022/05/24/graph/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Orlando Chen"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Orlando的窝"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">算法学习---图的基本算法</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2022-05-24 13:54:58" itemprop="dateCreated datePublished" datetime="2022-05-24T13:54:58+08:00">2022-05-24</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2022-05-31 08:09:03" itemprop="dateModified" datetime="2022-05-31T08:09:03+08:00">2022-05-31</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h1><h2 id="图的定义："><a href="#图的定义：" class="headerlink" title="图的定义："></a>图的定义：</h2><ul>
<li>图G由两个集合V和E组成，记为G&#x3D;(V,E)，其中V是顶点的有穷集合，E是顶点偶对（边）的有穷集合。</li>
<li>V(G),E(G)通常代表图G的顶点集合和边集合。若E(G)为有向边的集合，则该图为有向图；若E(G)为无向边的集合，则该图为无向图。</li>
</ul>
<h2 id="图的基本术语："><a href="#图的基本术语：" class="headerlink" title="图的基本术语："></a>图的基本术语：</h2><p>子图、无向完全图和有向完全图、稠密图与稀疏图、邻接点、度和入度和出度、路径和路径长度、回路或环、连通和连通图和联通分量、强连通图等等。<br><img src="https://img-blog.csdnimg.cn/20200829051207372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5MDcwNDk=,size_16,color_FFFFFF,t_70#pic_center" alt="图1" loading="lazy"></p>
<ul>
<li><strong>端点</strong>(end points)：对于边a来说，顶点U和顶点V是边a的两个端点。</li>
<li><strong>相邻</strong>（也称附带(incident)）：若一个顶点是一条边的端点，则我们说该条边与该顶点相邻。例如边a，b与d都与顶点V相邻。</li>
<li><strong>邻接点</strong>(adjacent)：一条边的两个端点互为邻接点。例如U和V。</li>
<li><strong>顶点的度</strong>(degree)：与一个顶点相邻的边的数量称为该顶点的度。例如X的度为5。</li>
<li><strong>平行边</strong>(Parallel edge)：若两条边的两个端点对应相同，则这两条边平行。例如图中的h与i。</li>
<li><strong>自循环边</strong>(self-loop edge)：<strong>两个端点相同的边</strong>称为自循环边。例如j。</li>
<li><strong>路径</strong>(Path)：一个包含不同顶点与边的序列。一条路径始于一个顶点，并终于一个顶点；路径序列（可以看成数组）中每条边的上一个元素是该条边的一个端点，下一个元素是该条边的另一个端点。</li>
<li><strong>简单路径</strong>(Simple path)：若一条路径中所有顶点与边均<strong>只出现一次</strong>，则该路径为简单路径。例如P1 &#x3D; (V, b, X, h, Z)是一条简单路径，P2 &#x3D; (U, c, W, e, X, g, Y, f, W, d, V)是一条路径，但不是一条简单路径，因为W出现了两次。</li>
<li><strong>循环</strong>(Cycle)：一个包含顶点与边的序列。始于一个顶点，终于一条边。若终于的那条边的一个端点是起始顶点，则这个序列是一个循环。</li>
<li><strong>简单循环</strong>(Simple cycle)：若一个循环中所有顶点与边均只出现一次，则该循环为简单循环。<br><img src="https://img-blog.csdnimg.cn/20190614102539684.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODcxNjU2Nw==,size_16,color_FFFFFF,t_70" alt="图2" loading="lazy"></li>
<li><strong>连通</strong>：<strong>无向图</strong>G中，顶点a到顶点b有路径，则称它们是连通的。</li>
<li><strong>连通图</strong>：V中任意两个顶点都是连通的，则G为连通图。</li>
<li><strong>连通分量</strong>：<strong>无向图</strong>中的极大连通子图。</li>
<li><strong>强连通图</strong>：<strong>有向图</strong>G中，V中任意两个顶点都是连通的，则G为强连通图。</li>
<li><strong>稀疏图</strong>（sparse graph）&amp;<strong>稠密图</strong>（dense graph）：有很少条边或弧（边的条数|E|远小于|V|²）的图称为稀疏图，反之边的条数|E|接近|V|²，称为稠密图。简单来讲就是，边越多，图越稠密。</li>
<li><strong>完全图</strong>：完全图是一个简单的无向图，其中每对不同的顶点之间都恰有一边相连。</li>
<li><strong>子图</strong>：节点集和边集分别是某一图的节点集的子集和边集的子集的图。</li>
<li><strong>加权图</strong>：用数学语言讲，设G为图，对图的每一条边e来说，都对应于一个实数W(e)（可以通俗的理解为边的“长度”，只是在数学定义中图的权可以为负数），我们把W（e）称为e的“权”。把这样的图G称为“加权图”。</li>
</ul>
<h2 id="图的实例："><a href="#图的实例：" class="headerlink" title="图的实例："></a>图的实例：</h2><p><a target="_blank" rel="noopener" href="https://wiki.mbalib.com/wiki/%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4%E7%90%86%E8%AE%BA">六度空间理论</a>（Six Degrees of Separation）、交通运输网络等等。</p>
<h1 id="图的表示（图的数据结构）"><a href="#图的表示（图的数据结构）" class="headerlink" title="图的表示（图的数据结构）"></a><strong>图的表示</strong>（图的数据结构）</h1><p>图分为有向图与无向图，有多种表示方法，可分为：</p>
<ul>
<li>初级表示：邻接表、邻接矩阵。</li>
<li>高级表示：十字链表法、邻接多重表、边集数组法。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Fitz_p/article/details/81263799">例题代码表示见此博客</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dzkang2011/p/graph_1.html">完整表示分析见此博客</a></li>
</ul>
<h2 id="邻接表与邻接矩阵："><a href="#邻接表与邻接矩阵：" class="headerlink" title="邻接表与邻接矩阵："></a>邻接表与邻接矩阵：</h2><ul>
<li>可以表示有向图，无向图，有向加权图，无向加权图。</li>
<li>通常采用邻接表表示法，因为用这种方法表示稀疏图比较紧凑。但当遇到稠密图或必须很快判别两个给定顶点是否存在连接边时，通常采用邻接矩阵表示法。例如求最短路径算法中，就采用邻接矩阵表示。</li>
</ul>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><ul>
<li>图的一种链式存储结构。</li>
<li>邻接表&#x3D;表头结点表+边表<ul>
<li>表头结点表：以顺序结构存储，便于随机访问任一顶点的边链表。<ul>
<li>表头结点：数据域+链域。<ul>
<li>数据域：存储顶点名称和其他信息。</li>
<li>链域：指向链表中第一个结点。</li>
</ul>
</li>
</ul>
</li>
<li>边表：邻接点域+数据域+链域。</li>
</ul>
</li>
<li>优势：便于增加和删除顶点；便于统计边的数目；空间效率高，对稀疏图表示有优势。</li>
<li>劣势：以顶点为单位地行保存，在大量边计划的场景下使用不方便，两个顶点之间是否有连接需要遍历；不便于判断两点间是否有边；不便于计算有向图各顶点的度。</li>
<li>场景：稀疏矩阵，图较大时，加权图时使用。</li>
<li>描述：<br><img src="https://img-blog.csdnimg.cn/20190614123537568.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODcxNjU2Nw==,size_16,color_FFFFFF,t_70" alt="描述" loading="lazy"></li>
<li>空间复杂度：O(n+m)</li>
<li>时间复杂度：O(n+m)</li>
<li>图G&#x3D;&lt;V，E&gt;的邻接表表示是由一个包含|V|个列表的数组Adj所组成，其中每个列表对应于V中的一个顶点。对于每一个u∈V，邻接表Adj[u]包含所有满足条件（u，v）∈E的顶点v。亦即，Adj[u]包含图G中所有和顶点u相邻的顶点。每个邻接表中的顶点一般以任意顺序存储。</li>
<li>如果G是一个有向图，则所有邻接表的长度之和为|E|，这是因为一条形如（u，v）的边是通过让v出现在Adj[u]中来表示的。</li>
<li>如果G是一个无向图，则所有邻接表的长度之和为2|E|，因为如果（u，v）是一条无向边，那么u会出现在v的邻接表中，反之亦然。邻接表需要的存储空间为O（V+E）。</li>
<li>入度表示法（逆邻接表）：<br><img src="https://img-blog.csdnimg.cn/20181122094334465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbnk4MjA0MTg=,size_16,color_FFFFFF,t_70" alt="入度" loading="lazy"></li>
</ul>
<h4 id="加权图表示"><a href="#加权图表示" class="headerlink" title="加权图表示"></a>加权图表示</h4><ul>
<li>邻接表稍作变动，即可用来表示加权图，即每条边都有着相应权值的图，权值通常由加权函数w：E→R给出。</li>
<li>例如，设G&#x3D;&lt;V，E&gt;是一个加权函数为w的加权图。对每一条边（u，v)∈E，权值w（u，v）和顶点v一起存储在u的邻接表中。<br><img src="https://img-blog.csdnimg.cn/20181122094526106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbnk4MjA0MTg=,size_16,color_FFFFFF,t_70" alt="加权邻接表" loading="lazy"></li>
</ul>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><ul>
<li>优势：直观，便于判断i j两点间是否有边，根据A[i][j]&#x3D;0或1判断；便于计算各顶点的度。</li>
<li>劣势：不便于增加或删除顶点；不利于计算边的数目；空间复杂度高。</li>
<li>场景：图较小时，优先使用；不加权时，存储空间上有优势，可以用一个bit来代表是否有连通。</li>
<li>观察无向图的邻接矩阵会发现，它是沿主对角线对称的。在一个无向图中，（u,v）和（v,u）表示同一条边，故无向图的邻接矩阵A的转置矩阵就是它本真。在某些应用中，可以<strong>只存储邻接矩阵的对角线以及对角线以上的部分</strong>，这样一来，图所占用的存储空间几乎可以减少一半。</li>
<li>描述：<br><img src="https://img-blog.csdnimg.cn/20190614110614659.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODcxNjU2Nw==,size_16,color_FFFFFF,t_70" alt="描述" loading="lazy"></li>
<li>空间复杂度：O(n^2)</li>
<li>时间复杂度：O(n^2)</li>
</ul>
<h4 id="加权图表示-1"><a href="#加权图表示-1" class="headerlink" title="加权图表示"></a>加权图表示</h4><p><img src="https://img-blog.csdnimg.cn/20181122094654893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbnk4MjA0MTg=,size_16,color_FFFFFF,t_70" alt="加权邻接矩阵" loading="lazy"></p>
<h2 id="十字链表法："><a href="#十字链表法：" class="headerlink" title="十字链表法："></a>十字链表法：</h2><p>把有向图的出度与入度结合起来表示：<br><img src="https://img-blog.csdnimg.cn/20181122100134811.png" alt="图1" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/20181122100041483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbnk4MjA0MTg=,size_16,color_FFFFFF,t_70" alt="图2" loading="lazy"></p>
<h2 id="邻接多重表："><a href="#邻接多重表：" class="headerlink" title="邻接多重表："></a>邻接多重表：</h2><ul>
<li>无向图关注的是边的话，使用该方法。</li>
<li>邻接表使用不便的情况如下：<br><img src="https://img-blog.csdnimg.cn/20181122103041714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbnk4MjA0MTg=,size_16,color_FFFFFF,t_70" alt="邻接表" loading="lazy"></li>
<li>邻接多重表设计方法：<br>仿照十字链表的方式，对边表结构进行改装，重新定义的边表结构如下：<table>
<thead>
<tr>
<th align="center">iVex</th>
<th align="center">iLink</th>
<th align="center">jVex</th>
<th align="center">jLink</th>
</tr>
</thead>
</table>
</li>
</ul>
<p>其中iVex和jVex是与某条边依附的两个顶点在顶点表中的下标。iLink指向依附顶点iVex的下一条边，jLink指向依附顶点jVex的下一条边。</p>
<ul>
<li>示意图：<br><img src="https://img-blog.csdnimg.cn/20181128111557505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbnk4MjA0MTg=,size_16,color_FFFFFF,t_70" alt="多重表" loading="lazy"></li>
</ul>
<h2 id="边集数组法："><a href="#边集数组法：" class="headerlink" title="边集数组法："></a>边集数组法：</h2><p><img src="https://img-blog.csdnimg.cn/20181122103948656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbnk4MjA0MTg=,size_16,color_FFFFFF,t_70" alt="边集数组" loading="lazy"></p>
<h1 id="图的搜索（DFS-amp-BFS）"><a href="#图的搜索（DFS-amp-BFS）" class="headerlink" title="图的搜索（DFS &amp; BFS）"></a><strong>图的搜索</strong>（DFS &amp; BFS）</h1><ul>
<li>图的遍历算法是求解图的连通性问题、拓扑排序和关键路径等算法的基础。</li>
<li>根据路径的搜索路径的方向，通常有：深度优先搜索（DFS）和广度优先搜索（BFS）两种遍历图的途径。对无向图、有向图都适用。</li>
</ul>
<h2 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h2><ul>
<li>深度优先搜索的数据结构为栈(stack）。</li>
<li>深度优先搜索的两个注意事项：<ul>
<li>回溯（回溯时要恢复原来状态）</li>
<li>剪枝<h3 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h3>从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念。</li>
</ul>
</li>
</ul>
<h3 id="模拟搜索过程："><a href="#模拟搜索过程：" class="headerlink" title="模拟搜索过程："></a>模拟搜索过程：</h3><p><img src="https://img-blog.csdnimg.cn/6cdb8fcefeca4c2aaf507254c6d4f250.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rWq6YeM5bCP55m96b6ZbmJ3,size_20,color_FFFFFF,t_70,g_se,x_16" alt="搜索过程图" loading="lazy"></p>
<h3 id="表示方式："><a href="#表示方式：" class="headerlink" title="表示方式："></a>表示方式：</h3><ul>
<li>DFS遍历类似于树的先序遍历。采用不同数据结构的DFS具体实现：<br><img src="https://img-blog.csdnimg.cn/2019061417370630.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODcxNjU2Nw==,size_16,color_FFFFFF,t_70" alt="图1" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/2019061417370630.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODcxNjU2Nw==,size_16,color_FFFFFF,t_70" alt="图2" loading="lazy"></li>
<li>邻接矩阵表示时查找每个顶点的邻接点的时间复杂度是O(n^2)，n是顶点数。</li>
<li>邻接表表示时查找邻接点的时间复杂度是O(e)，e是边数，所以此时用DFS遍历图的时间复杂度为O(n+e)。</li>
</ul>
<h3 id="DFS中边的相关问题："><a href="#DFS中边的相关问题：" class="headerlink" title="DFS中边的相关问题："></a>DFS中边的相关问题：</h3><p>无向图中只有树边和回边。<br>有向图中对边的种类进行细分：（发起点——&gt;接受点，中间-&gt;即为边）</p>
<ul>
<li>树边（Tree Edge）：从一个顶点指向其未访问过的子节点的边。</li>
<li>前向边（Forward Edge）：从一个顶点指向该顶点的一个非子顶点后裔的边，且接受点被访问过。</li>
<li>回边（Back Edge）：从一个顶点指向其祖先顶点的边。</li>
<li>横跨边（Cross Edge）：从一个顶点指向一个已完全访问过的顶点，且其中接受点既不是发起点的的后裔，也不是其祖先。<br><img src="https://img-blog.csdnimg.cn/20190802211019465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NfWmhhbmdTaXI=,size_16,color_FFFFFF,t_70" alt="图解" loading="lazy"></li>
</ul>
<p><strong>规律</strong>：<br>树边、前向边，都是往前指，即顺着bfs遍历的顺序；回边是往回指，即逆着bfs遍历的顺序；横跨边横着指，即边的两个端点没有祖先、后裔关系。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="体现回溯"><a href="#体现回溯" class="headerlink" title="体现回溯"></a>体现回溯</h4><p>把 1∼n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
<ul>
<li>输入格式<br>一个整数 n。</li>
<li>输出格式<br>按照从小到大的顺序输出所有方案，每行 1 个。<br>首先，同一行相邻两个数用一个空格隔开。<br>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。</li>
<li>数据范围：1≤n≤9</li>
<li>题目分析：<br>当要求字典序的时候，我们从小到大枚举每个数，结果就是字典序。这里我们从位置的角度来思考问题，每个位置应该放哪些数。当第一个位置放1时…,放2时…,放3时…。</li>
<li>代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> state[N];   <span class="comment">// 0 表示还没放数，1~n表示放了哪个数</span></span><br><span class="line"><span class="type">bool</span> used[N];   <span class="comment">// true表示用过，false表示还未用过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; n)  <span class="comment">// 边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, state[i]); <span class="comment">// 打印方案</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次枚举每个分支，即当前位置可以填哪些数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!used[i])</span><br><span class="line">        &#123;</span><br><span class="line">            state[u] = i;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>); <span class="comment">//递归搜索下一个位置</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 恢复现场</span></span><br><span class="line">            state[u] = <span class="number">0</span>;  <span class="comment">//回溯</span></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);<span class="comment">//从第一个位置开始搜索遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="剪枝优化———n-皇后问题"><a href="#剪枝优化———n-皇后问题" class="headerlink" title="剪枝优化———n-皇后问题"></a>剪枝优化———n-皇后问题</h4><p>n−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。<br><img src="https://img-blog.csdnimg.cn/ff7553b5fd9341bd81e3a25af07790ab.png" alt="棋盘图" loading="lazy"><br>现在给定整数 n，请你输出所有的满足条件的棋子摆法。</p>
<ul>
<li>输入格式<br>共一行，包含整数 n。</li>
<li>输出格式<br>每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。<br>其中 . 表示某一个位置的方格状态为空，Q 表示某一个位置的方格上摆着皇后。<br>每个方案输出完成后，输出一个空行。<br>注意：行末不能有多余空格。<br>输出方案的顺序任意，只要不重复且没有遗漏即可。</li>
<li>数据范围：1≤n≤9</li>
<li>题目分析：<br>此题可采用深度优先遍历(递归)来进行求解，我们可以先在棋盘的第一行放第一个皇后(从第一列开始)，然后再在第二行上放第二个皇后(也从第一列开始)，易知如果第二个皇后也放在第一列的话就不满足题意，此时需要将第二行的皇后放在第二列…直到满足条件为止，以此类推直到每一行的皇后都放在了正确的位置，此时有了一个答案，然后我们改变最后一行皇后的位置，继续寻找满足条件的答案，当最后一行的所有位置都改变后，我们开始改变倒数第二行皇后的位置来继续寻找满足条件的答案，需要注意的是倒数第二行的皇后每改变一个位置，倒数第一行就要从头开始遍历每个位置…以此类推第一行的皇后位置改变后，后面的所有行位置都需要重新遍历搜索！</li>
<li>代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N * <span class="number">2</span>], udg[N * <span class="number">2</span>];  <span class="comment">//行、列、对角线、反对角线</span></span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">//存储图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span>   <span class="comment">//s代表第几个皇后</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (y == n) y = <span class="number">0</span>, x ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s);</span><br><span class="line">	<span class="comment">//判断是否满足条件进行`剪枝`</span></span><br><span class="line">    <span class="keyword">if</span> (!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n]) </span><br><span class="line">    &#123;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>代码分析：<br><img src="https://img-blog.csdnimg.cn/21e7cae3528540809d314009d87a7af2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rWq6YeM5bCP55m96b6ZbmJ3,size_20,color_FFFFFF,t_70,g_se,x_16" alt="分析图" loading="lazy"></li>
</ul>
<h2 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>广度优先搜索（也称宽度优先搜索，缩写BFS，以下采用广度来描述）是连通图的一种遍历策略。因为它的思想是从一个顶点V0开始，辐射状地优先遍历其周围较广的区域，因此得名。</p>
<ul>
<li>为了便于进行搜索，要设置一个表存储所有的结点。由于在广度优先搜索算法中，要满足先生成的结点先扩展的原则，所以存储结点的表一般采用队列这种数据结构。</li>
<li>BFS遍历类似于树的按层次遍历。<br>利用辅助队列进行遍历，每个顶点至多进一次队列（同一层的存在同一队列中）。</li>
</ul>
<h3 id="搜索框架："><a href="#搜索框架：" class="headerlink" title="搜索框架："></a>搜索框架：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  BFS（）</span><br><span class="line">&#123;</span><br><span class="line">    队列初始化；</span><br><span class="line">    初始结点入队；</span><br><span class="line">    <span class="keyword">while</span> （队列非空）</span><br><span class="line">    &#123;  </span><br><span class="line">          队头元素出队，赋给current；</span><br><span class="line">          <span class="keyword">while</span>  （current 还可以扩展）</span><br><span class="line">          &#123;</span><br><span class="line">              由结点current扩展出新结点<span class="keyword">new</span>；</span><br><span class="line">              <span class="keyword">if</span>  （<span class="keyword">new</span> 重复于已有的结点状态） <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">new</span>结点入队；</span><br><span class="line">              <span class="keyword">if</span>  (<span class="keyword">new</span>结点是目标状态)</span><br><span class="line">              &#123;</span><br><span class="line">                    置flag= <span class="literal">true</span>;    <span class="keyword">break</span>; </span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul>
<li>最直观经典的例子就是<strong>走迷宫</strong>。从起点开始，找出到终点的最短路程，很多最短路径算法就是基于广度优先的思想成立的。</li>
<li>判断是否有环：利用BFS，如果访问到之前访问过的点，则存在环。</li>
<li>是否为二部图：利用BFS进行上色，如果本层与下层存在同色，则不可二划分。</li>
</ul>
<h3 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h3><p><img src="/images/BFS.png" alt="流程图" loading="lazy"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Vs 起点 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Vd 终点 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">bool <span class="title function_">BFS</span><span class="params">(Node&amp; Vs, Node&amp; Vd)</span>&#123;  </span><br><span class="line">    queue&lt;Node&gt; Q;  </span><br><span class="line">    Node Vn, Vw;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始状态将起点放进队列Q  </span></span><br><span class="line">    Q.push(Vs);  </span><br><span class="line">    hash(Vw) = <span class="literal">true</span>;<span class="comment">//设置节点已经访问过了！  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())&#123;<span class="comment">//队列不为空，继续搜索！  </span></span><br><span class="line">        <span class="comment">//取出队列的头Vn  </span></span><br><span class="line">        Vn = Q.front();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//从队列中移除  </span></span><br><span class="line">        Q.pop();  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(Vw = Vn通过某规则能够到达的节点)&#123;  </span><br><span class="line">            <span class="keyword">if</span> (Vw == Vd)&#123;<span class="comment">//找到终点了！  </span></span><br><span class="line">                <span class="comment">//把路径记录，这里没给出解法  </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回  </span></span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isValid(Vw) &amp;&amp; !visit[Vw])&#123;  </span><br><span class="line">                <span class="comment">//Vw是一个合法的节点并且为白色节点  </span></span><br><span class="line">                Q.push(Vw);<span class="comment">//加入队列Q  </span></span><br><span class="line">                hash(Vw) = <span class="literal">true</span>;<span class="comment">//设置节点颜色  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//无解  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>PS：</strong>对于一个题目来说，要标志节点是否访问过，用数组是一种很快速的方法，但有时数据量太大，很难用一个大数组来记录时，采用hash set是最好的做法。实际上visit数组在这里也是充当hash set的作用。</li>
</ul>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="黑色方块"><a href="#黑色方块" class="headerlink" title="黑色方块"></a>黑色方块</h4><ul>
<li>问题描述：有一个宽为W、高为H的矩形平面，用黑色和红色两种颜色的方砖铺满。一个小朋友站在一块黑色方块上开始移动，规定移动方向有上、下、左、右四种，且只能在黑色方块上移动（即不能移到红色方块上）。编写一个程序，计算小朋友从起点出发可到达的所有黑色方砖的块数（包括起点）。<br>例如，如图所示的矩形平面中，“#”表示红色砖块，“．”表示黑色砖块，“@”表示小朋友的起点，则小朋友能走到的黑色方砖有28块。<br><img src="https://img2018.cnblogs.com/blog/1485495/201907/1485495-20190707192821931-136919482.png" alt="图1" loading="lazy"></li>
<li>编程思路：<ul>
<li>采用广度优先搜索法解决这个问题。</li>
<li>用数组q模拟队列操作，front为队头指针，rear为队尾指针，初始时front&#x3D;rear&#x3D;0。</li>
<li>入队操作为 q[rear++]&#x3D;cur;</li>
<li>出队操作为 cur&#x3D;q[front++]。</li>
<li>程序中定义方砖的位置坐标（x,y）为Node类型，定义数组int visit[N][N]标记某方砖是否已走过，visit[i][j]&#x3D;0表示坐标（i,j）处的方砖未走过，visit[i][j]&#x3D;1表示坐标（i,j）处的方砖已走过。初始时visit数组的所有元素值均为0。</li>
</ul>
</li>
<li>具体算法步骤：<br>① 将出发点（startx，starty）入队列q，且置visit[startx][starty]&#x3D;1，表示该处的方砖已被处理，以后不再重复搜索。<br>② 将队列q的队头元素出栈，得到一个当前方砖cur，黑色方砖计数（sum++），沿其上、下、左、右四个方向上搜索未走过的黑色方砖，将找到的黑色方砖的坐标入队列q。<br>③ 重复执行②，直至队列q为空，则求出了所有能走过的黑色方砖数。</li>
<li>解答：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> map[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> visit[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> startx, <span class="type">int</span> starty,<span class="type">int</span> w,<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       Node q[N*N],cur,next;   <span class="comment">// q为队列</span></span><br><span class="line">       <span class="type">int</span>  front,rear;        <span class="comment">// front为队头指针，rear为队尾指针</span></span><br><span class="line">       <span class="type">int</span> i,x,y,sum;    </span><br><span class="line">       front=rear=<span class="number">0</span>;           <span class="comment">// 队列q初始化</span></span><br><span class="line">       sum=<span class="number">0</span>;</span><br><span class="line">       cur.x=startx;   cur.y=starty; </span><br><span class="line">       visit[startx][starty]=<span class="number">1</span>;</span><br><span class="line">       q[rear++]=cur;          <span class="comment">// 初始结点入队</span></span><br><span class="line">       <span class="keyword">while</span>(rear!=front)      <span class="comment">// 队列不为空</span></span><br><span class="line">       &#123;</span><br><span class="line">              cur=q[front++];     <span class="comment">// 队头元素出队</span></span><br><span class="line">              sum++;              <span class="comment">// 方砖计数</span></span><br><span class="line">              <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">              &#123;</span><br><span class="line">                  x=cur.x+dx[i];  y=cur.y+dy[i];</span><br><span class="line">                 <span class="keyword">if</span>(x &gt;=<span class="number">0</span> &amp;&amp; x&lt;h &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;w &amp;&amp; map[x][y]!=<span class="string">&#x27;#&#x27;</span> &amp;&amp; visit[x][y]==<span class="number">0</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                        visit[x][y] = <span class="number">1</span>;</span><br><span class="line">                        next.x=x;  next.y=y;  <span class="comment">// 由cur扩展出新结点next</span></span><br><span class="line">                        q[rear++]=next;       <span class="comment">// next结点入队</span></span><br><span class="line">                  &#125; </span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i,j,pos_x,pos_y,w,h,sum;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       cin&gt;&gt;w&gt;&gt;h;</span><br><span class="line">        <span class="keyword">if</span> (w==<span class="number">0</span> &amp;&amp; h==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;h;i++)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;w;j++)</span><br><span class="line">          &#123;</span><br><span class="line">              cin&gt;&gt;map[i][j];</span><br><span class="line">              <span class="keyword">if</span> (map[i][j]==<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                pos_x = i;</span><br><span class="line">                pos_y = j;</span><br><span class="line">             &#125;</span><br><span class="line">              visit[i][j] = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sum=<span class="built_in">bfs</span>(pos_x, pos_y,w,h);</span><br><span class="line">      cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a>Word Ladder</h4><p><img src="/images/BFST1.png" alt="例1" loading="lazy"></p>
<ul>
<li>问题描述：根据给定单词，找出可以转换的最短距离。</li>
<li>要求：<br>①每次只能变换一个字母<br>②每个字符串长度相同<br>③每次转换的字符串必须在wordList中<br>④如果没有这种转换，返回0<br>⑤没有重复的</li>
<li>思路说明：<br>① 构造一个字典，key为”ot”,”h_t”,”ho“这样的形式，即可把满足只变化一个字母的单词归并到同一个key的value中了。<br>② 运用BFS来做</li>
<li>解答；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function">    def ladderLength(self, beginWord, endWord, wordList):</span></span><br><span class="line"><span class="function">    # beginWord为开始的单词，endWord为目标单词，wordList为可供转换的元素组成的列表</span></span><br><span class="line"><span class="function">        def construct_dict():</span></span><br><span class="line"><span class="function">            d =</span> &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> word in wordList:</span><br><span class="line">                <span class="function"><span class="keyword">for</span> i in <span class="title">xrange</span><span class="params">(len(word))</span>:</span></span><br><span class="line"><span class="function">                    s =</span> s[:i] + <span class="string">&quot;_&quot;</span> + s[i+<span class="number">1</span>:]</span><br><span class="line">                    d[s] = d.<span class="built_in">get</span>(s, []) + [word]</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line">        def <span class="built_in">bfs</span>(begin, target, d):</span><br><span class="line">            queue, visited = [(begin, <span class="number">1</span>)], <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">                word, steps = queue.<span class="built_in">pop</span>(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">not</span> in visited:</span><br><span class="line">                    visited.<span class="built_in">add</span>(word)</span><br><span class="line">                    <span class="keyword">if</span> word == target:</span><br><span class="line">                        <span class="keyword">return</span> steps</span><br><span class="line">                    <span class="keyword">for</span> i in <span class="built_in">xrange</span>(<span class="built_in">len</span>(word)):</span><br><span class="line">                        s = word[:i] + <span class="string">&quot;_&quot;</span> + word[i+<span class="number">1</span>:]</span><br><span class="line">                        <span class="keyword">for</span> j in d.<span class="built_in">get</span>(s, []):</span><br><span class="line">                            # 如果j在visited中，说明j已经被访问过了，不需要再次进行访问。</span><br><span class="line">                            <span class="keyword">if</span> j <span class="keyword">not</span> in visited:</span><br><span class="line">                                queue.<span class="built_in">append</span>((j, steps+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        d = <span class="built_in">construct_dict</span>()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bfs</span>(beginWord, endWord, d)</span><br></pre></td></tr></table></figure>
<h4 id="Word-Break-II"><a href="#Word-Break-II" class="headerlink" title="Word Break II"></a>Word Break II</h4><img src="/images/BFST2.png" alt="例2" loading="lazy"></li>
<li>问题描述：给定一个字符串和一个字典，判断字典是否包含可以构成这个字符串的元素，如果有，返回由这些单词组成的字符串，以列表形式表示。</li>
<li>思路说明：<br>这道题特别好，考察了BFS和DFS的联合使用。<br>基于BFS的主要想法是：图的顶点Vi可以用每个单词的第一个字母所在的索引来表示，图的边Eij则用单词表示。<br>以nightmare为例，比如我们划分成了night mare，那么图应该为<br>0 —&gt; 5 —&gt; 9。<br>于是问题转换成了，检查是否有一条路径从0到9（并列出所有的可能，需要用到DFS了）</li>
<li>解答：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function">    def wordBreak(self, s, wordDict):</span></span><br><span class="line"><span class="function">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="function">        s 目标字符串</span></span></span><br><span class="line"><span class="string"><span class="function">        wordDict 存放可能组成s的元素组成的列表</span></span></span><br><span class="line"><span class="string"><span class="function">        返回值 列表List</span></span></span><br><span class="line"><span class="string"><span class="function">    &quot;</span><span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="function">        self.val =</span> []</span><br><span class="line">        self.<span class="built_in">dfs</span>(s, wordDict, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.val</span><br><span class="line"></span><br><span class="line">    def <span class="built_in">dfs</span>(self, s, wordDict, ret):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            ret = ret.<span class="built_in">strip</span>()</span><br><span class="line">            ret = ret.<span class="built_in">split</span>()[::<span class="number">-1</span>]</span><br><span class="line">            ret = <span class="built_in">reduce</span>(lambda x,y: x + <span class="string">&quot; &quot;</span> + y,ret, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            self.val.<span class="built_in">append</span>(ret.<span class="built_in">strip</span>())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            bfs = [] # 队列</span><br><span class="line">            visited = <span class="built_in">set</span>() # 访问过的点，访问过的不再访问</span><br><span class="line">            bfs.<span class="built_in">append</span>(<span class="number">0</span>) # 队列初始化</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(bfs) &gt; <span class="number">0</span>:</span><br><span class="line">                start = bfs.<span class="built_in">pop</span>(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> start <span class="keyword">not</span> in visited:</span><br><span class="line">                    visited.<span class="built_in">add</span>(start)</span><br><span class="line">                    <span class="keyword">for</span> j in <span class="built_in">xrange</span>(start+<span class="number">1</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">                        word = s[start:j] </span><br><span class="line">                        <span class="keyword">if</span> word in wordDict:</span><br><span class="line">                            bfs.<span class="built_in">append</span>(j)</span><br><span class="line">                            <span class="keyword">if</span> j == <span class="built_in">len</span>(s):</span><br><span class="line">                                self.<span class="built_in">dfs</span>(s[:start], wordDict, ret + <span class="string">&quot; &quot;</span> + word)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结分析"><a href="#总结分析" class="headerlink" title="总结分析"></a>总结分析</h3><ul>
<li>假设图有V个顶点，E条边，广度优先搜索算法需要搜索V个节点，因此这里的消耗是O(V)，在搜索过程中，又需要根据边来增加队列的长度，于是这里需要消耗O(E)，总得来说，效率大约是O(V+E)。</li>
<li>最影响BFS算法的是在于Hash运算，我们前面给出了一个visit数组，已经算是最快的Hash了，但有些题目来说可能Hash的速度要退化到O(lgn)的复杂度，当然了，具体还是看实际情况的。</li>
<li>BFS适合此类题目：<strong>给定初始状态跟目标状态，要求从初始状态到目标状态的最短路径</strong>。</li>
</ul>
<h2 id="深度与广度的比较"><a href="#深度与广度的比较" class="headerlink" title="深度与广度的比较"></a>深度与广度的比较</h2><ul>
<li>搜索一个图是按照树的层次来搜索的。</li>
<li>广度优先搜索的缺点：在树的层次较深&amp;子节点数较多的情况下，消耗内存十分严重。广度优先搜索适用于节点的子节点数量不多，并且树的层次不会太深的情况。</li>
<li>深度优先搜索的<strong>缺点</strong>：难以寻找最优解，仅仅只能寻找有解。其<strong>优点</strong>就是内存消耗小，克服了上述广度优先搜索的缺点。</li>
<li>详情分析见此<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cs-whut/p/11149521.html">博客</a></li>
</ul>
<h1 id="强连通分支"><a href="#强连通分支" class="headerlink" title="强连通分支"></a><strong>强连通分支</strong></h1><h2 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h2><ul>
<li>在有向图G中，如果两个顶点u，ｖ间有一条从ｕ到ｖ的有向路径，同时还有一条从ｖ到ｕ的有向路径，则称两个顶点强连通(strongly connected)。</li>
<li>如果有向图G的每两个顶点都强连通，称G是一个强连通图。</li>
<li>非强连通有向图的极大强连通子图，称为强连通分量(strongly connected components)。</li>
<li>例子：图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达。{5},{6}也分别是两个强连通分量。<br><img src="https://img2018.cnblogs.com/blog/1749451/201909/1749451-20190921121215388-749051872.png" alt="例图" loading="lazy"></li>
</ul>
<h2 id="Tarjan算法："><a href="#Tarjan算法：" class="headerlink" title="Tarjan算法："></a>Tarjan算法：</h2><ul>
<li>Tarjan算法是用来求有向图的强连通分量的。</li>
<li>Tarjan算法时间复杂度是O(N+M)。</li>
<li>Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。 定义DFN(u)为节点u搜索的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。 由定义可以得出，Low(u)&#x3D;Min {Low(u), Low(v) } (u,v)为树枝边，u为v的父节点 . Low(u)&#x3D;Min {Low(u), DFN(v) } DFN(v),(u,v)为指向栈中节点的后向边(指向栈中结点的横叉边)。当结点u搜索结束后，若DFN(u)&#x3D;Low(u)时，则以u为根的搜索子树上所有还在栈中的节点是一个强连通分量。</li>
</ul>
<h3 id="算法过程："><a href="#算法过程：" class="headerlink" title="算法过程："></a>算法过程：</h3><ul>
<li>从节点1开始DFS，把遍历到的节点加入栈中。搜索到节点u&#x3D;6时，DFN[6]&#x3D;LOW[6]，找到了一个强连通分量。退栈到u&#x3D;v为止，{6}为一个强连通分量。<br><img src="https://img2018.cnblogs.com/blog/1749451/201909/1749451-20190921121447386-1658019050.png" alt="图1" loading="lazy"></li>
<li>初始化时Low[u]&#x3D;DFN[u]&#x3D;++index<br>返回节点5，发现DFN[5]&#x3D;LOW[5]，退栈后{5}为一个强连通分量。<br><img src="https://img2018.cnblogs.com/blog/1749451/201909/1749451-20190921121522859-1841133664.png" alt="图2" loading="lazy"></li>
<li>返回节点3，继续搜索到节点4，把4加入堆栈。发现节点4向节点1有后向边，节点1还在栈中，所以LOW[4]&#x3D;1。节点6已经出栈，(4,6)是横叉边，返回3，(3,4)为树枝边，所以LOW[3]&#x3D;LOW[4]&#x3D;1。<br><img src="https://img2018.cnblogs.com/blog/1749451/201909/1749451-20190921122333141-1771436400.png" alt="图3" loading="lazy"></li>
<li>继续回到节点1，最后访问节点2。访问边(2,4)，4还在栈中，所以LOW[2]&#x3D;DFN[4]&#x3D;5。返回1后，发现DFN[1]&#x3D;LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。<br><img src="https://img2018.cnblogs.com/blog/1749451/201909/1749451-20190921121537724-31133813.png" alt="图4" loading="lazy"></li>
<li>至此，算法结束。求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。</li>
<li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> u)</span> <span class="comment">//tarjan缩点</span></span><br><span class="line">&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;</span><br><span class="line">    st[++top]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])<span class="comment">//深度优先</span></span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u]=min(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!co[v])<span class="comment">//判断是否在栈中</span></span><br><span class="line">            low[u]=min(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u]==dfn[u])<span class="comment">//退栈</span></span><br><span class="line">    &#123;</span><br><span class="line">        co[u]=++col<span class="comment">//记录第几个集合</span></span><br><span class="line">        ++si[col];<span class="comment">//记录集合数量</span></span><br><span class="line">        <span class="keyword">while</span>(st[top]!=u)</span><br><span class="line">        &#123;</span><br><span class="line">            ++si[col];</span><br><span class="line">            co[st[top]]=col;</span><br><span class="line">            --top;</span><br><span class="line">        &#125;</span><br><span class="line">        --top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Tarjan算法用途："><a href="#Tarjan算法用途：" class="headerlink" title="Tarjan算法用途："></a>Tarjan算法用途：</h3><h4 id="有向图的缩点"><a href="#有向图的缩点" class="headerlink" title="有向图的缩点"></a>有向图的缩点</h4><p>将同一个强连通分量中的点缩成同一个新结点，对于两个新结点a,b之间有边相连，当且仅当存在两个点u属于a，v属于b。<br><img src="/images/Topo1.png" alt="图1" loading="lazy"><br><img src="/images/Topo2.png" alt="图2" loading="lazy"></p>
<h4 id="求割点和桥"><a href="#求割点和桥" class="headerlink" title="求割点和桥"></a>求割点和桥</h4><h3 id="例题————受欢迎的牛"><a href="#例题————受欢迎的牛" class="headerlink" title="例题————受欢迎的牛"></a>例题————受欢迎的牛</h3><ul>
<li>问题描述：每一头牛的愿望就是变成一头最受欢迎的牛。现在有 N 头牛，给你 M 对整数 (A,B)，表示牛 A 认为牛 B 受欢迎。这种关系是具有传递性的，如果 A 认为 B 受欢迎，B 认为 C 受欢迎，那么牛 A 也认为牛 C 受欢迎。你的任务是求出有多少头牛被除自己之外的所有牛认为是受欢迎的。</li>
<li>输入：<br>第一行两个数 N,M；<br>接下来 M 行，每行两个数 A,B，意思是 A 认为 B 是受欢迎的（给出的信息有可能重复，即有可能出现多个 A,B）。</li>
<li>输出：<br>输出被除自己之外的所有牛认为是受欢迎的牛的数量。</li>
<li>输入样例：<br>3 3<br>1 2<br>2 1<br>2 3</li>
<li>输出样例：1<br>(即只有第三头牛满足条件)</li>
<li>数据范围：对于全部数据，1≤N≤104,1≤M≤5×104</li>
<li>代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxN=<span class="number">1e4</span>+<span class="number">5</span>,maxN=<span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> to[maxM],nex[maxM],fir[maxN];</span><br><span class="line"><span class="type">int</span> col,num,dfn[maxN],low[maxN],de[maxN],si[maxN];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">0</span>,co[maxN],n,m,top,st[maxN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> <span class="comment">//tarjan缩点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;</span><br><span class="line">    st[++top]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fir[u];i;i=nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])<span class="comment">//深度优先</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!co[v])<span class="comment">//判断是否在栈中</span></span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u]==dfn[u])<span class="comment">//退栈</span></span><br><span class="line">    &#123;</span><br><span class="line">        co[u]=++col<span class="comment">//记录第几个集合</span></span><br><span class="line">        ++si[col];<span class="comment">//记录集合数量</span></span><br><span class="line">        <span class="keyword">while</span>(st[top]!=u)</span><br><span class="line">        &#123;</span><br><span class="line">            ++si[col];</span><br><span class="line">            co[st[top]]=col;</span><br><span class="line">            --top;</span><br><span class="line">        &#125;</span><br><span class="line">        --top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//添加x到y的边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++tot]=y;</span><br><span class="line">    nex[tot]=fir[x];</span><br><span class="line">    fir[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">ins</span>(y,x);<span class="comment">//反向，题中的统计入度就变成统计出度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])<span class="comment">//缩点</span></span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=fir[i];j;nex[j])<span class="comment">//统计入度</span></span><br><span class="line">            <span class="keyword">if</span>(co[i]!=co[to[j]])<span class="comment">//不在一个集合就统计入度</span></span><br><span class="line">                de[co[to[j]]]++;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=col;i++)</span><br><span class="line">        <span class="keyword">if</span>(!de[i])<span class="comment">//记录入度为0的点，有多个则输出0</span></span><br><span class="line">            ans=si[i],u++;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a><strong>拓扑排序</strong></h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。<blockquote>
<p>任何 DAG 具有至少一个拓扑排序，并且已知这些算法用于在线性时间内构建任何 DAG 的拓扑排序。</p>
</blockquote>
</li>
<li>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（英语：Topological sorting）:<ul>
<li>每个顶点出现且只出现一次.</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li>
</ul>
</li>
<li>由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</li>
</ul>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>在一个有向图中，对所有的节点进行排序，要求没有一个节点指向它前面的节点。</li>
<li>先统计所有节点的入度，对于入度为0的节点就可以分离出来，然后把这个节点指向的节点的入度减一。</li>
<li>一直做改操作，直到所有的节点都被分离出来。</li>
<li>如果最后不存在入度为0的节点，但还存在节点，那就说明有环，不存在拓扑排序，也就是很多题目的无解的情况。<br><img src="https://img-blog.csdnimg.cn/20210421164716512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoeVRhbg==,size_16,color_FFFFFF,t_70" alt="例图" loading="lazy"></li>
</ul>
<h2 id="基本实现思路"><a href="#基本实现思路" class="headerlink" title="基本实现思路"></a>基本实现思路</h2><ul>
<li>先把入度为0 的节点找到并打印。</li>
<li>删掉入度为0的节点，继续循环1的步骤，直至图为null。</li>
</ul>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><h3 id="初步思路"><a href="#初步思路" class="headerlink" title="初步思路"></a>初步思路</h3><ul>
<li>遍历整个图中的顶点，找出入度为0的顶点，然后标记删除该顶点，更新相关顶点的入度。</li>
<li>由于图中有V个顶点，每次找出入度为0的顶点后会更新相关顶点的入度，因此下一次又要重新扫描图中所有的顶点。故**时间复杂度为O(V^2)**。</li>
<li><strong>问题</strong>：由于删除入度为0的顶点时，只会更新与它邻接的顶点的入度，即只会影响与之邻接的顶点。但是上面的方式却遍历了图中所有的顶点的入度。</li>
</ul>
<h3 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h3><ul>
<li>先将入度为0的顶点放在栈或者队列中。当队列不空时，删除一个顶点v，然后更新与顶点v邻接的顶点的入度。只要有一个顶点的入度降为0，则将之入队列。</li>
<li>此时，拓扑排序就是顶点出队的顺序。该算法的<strong>时间复杂度为O（V+E）</strong>。</li>
</ul>
<h2 id="拓扑排序方法实现"><a href="#拓扑排序方法实现" class="headerlink" title="拓扑排序方法实现"></a>拓扑排序方法实现</h2><ul>
<li>该算法借助队列来实现时，感觉与二叉树的层序遍历算法很相似。拓扑排序是基于DFS的，只是加入了一个栈来保存结果。</li>
<li>具体步骤：<ul>
<li>第一步：遍历图中所有的顶点，将入度为0的顶点入队列。</li>
<li>第二步：从队列中出一个顶点，打印顶点，更新该顶点的邻接点的入度(减1)，如果邻接点的入度减1之后变成了0，则将该邻接点入队列。</li>
<li>第三步：一直执行上面第二步，直到队列为空。</li>
</ul>
</li>
<li>核心代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">topoSort</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//判断是否所有的顶点都出队了,若有顶点未入队(组成环的顶点)，则这些顶点肯定不会出队</span></span><br><span class="line"> </span><br><span class="line">        Queue&lt;Vertex&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">// 拓扑排序中用到的栈,也可用队列.</span></span><br><span class="line">        <span class="comment">//扫描所有的顶点,将入度为0的顶点入队列</span></span><br><span class="line">        Collection&lt;Vertex&gt; vertexs = directedGraph.values();</span><br><span class="line">        <span class="keyword">for</span> (Vertex vertex : vertexs)</span><br><span class="line">            <span class="keyword">if</span>(vertex.inDegree == <span class="number">0</span>)</span><br><span class="line">                queue.offer(vertex);</span><br><span class="line">        <span class="comment">//度为0的顶点出队列并且更新它的邻接点的入度</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">v</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.print(v.vertexLabel + <span class="string">&quot; &quot;</span>);<span class="comment">//输出拓扑排序的顺序</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (Edge e : v.adjEdges)</span><br><span class="line">                <span class="keyword">if</span>(--e.endVertex.inDegree == <span class="number">0</span>)</span><br><span class="line">                    queue.offer(e.endVertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count != directedGraph.size())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Graph has circle&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>说明：<ul>
<li>第7行for循环：先将图中所有入度为0的顶点入队列。</li>
<li>第11行while循环：将入度为0的顶点出队列，并更新与之邻接的顶点的入度，若邻接顶点的入度降为0，则入队列（第16行if语句）。</li>
<li>第19行if语句判断图中是否有环。因为，只有在每个顶点出队时，count++。对于组成环的顶点，是不可能入队列的，因为组成环的顶点的入度不可能为0（第16行if语句不会成立）.</li>
<li>利用栈先进后出的性质，将入度为0的顶点依次入栈。栈的性质可以使得输出顶点数少于原有顶点数得以实现。</li>
<li>因此，如果有环，count的值一定小于图中顶点的个数。</li>
</ul>
</li>
<li>时间复杂度分析：对于有n个顶点，e条边的有向图而言，求各顶点入度的时间复杂度为O(e)，建立0入度顶点栈的时间复杂度为O(n)，所以总的时间复杂度为O(n+e)。</li>
<li>核心代码见此<a target="_blank" rel="noopener" href="https://blog.csdn.net/ShyTan/article/details/115962715">博客</a></li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>拓扑排序通常用来“排序”具有依赖关系的任务。</p>
<h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p>如果用一个DAG图来表示一个课程修读关系图，其中每个顶点表示学期中的一个课程，用有向边 表示在学习务课程B 之前必须先学习课程 A。故在这个体系中，任意两个课程要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。<br><img src="/images/TopoEg1.png" alt="例1" loading="lazy"></p>
<h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p>比如我们早上起来穿衣服，也遵循一种流程：<br><img src="/images/TopoEg2.png" alt="例2" loading="lazy"></p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Orlando Chen</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://orlando-chen.github.io/2022/05/24/graph/" title="算法学习---图的基本算法">https://orlando-chen.github.io/2022/05/24/graph/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/05/31/tree/" rel="prev" title="算法学习---最小生成树"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">算法学习---最小生成树</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/05/21/GAvsDP/" rel="next" title="算法学习---贪心算法VS动态规划"><span class="post-nav-text">算法学习---贪心算法VS动态规划</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Orlando Chen</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v6.1.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.9.0</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>